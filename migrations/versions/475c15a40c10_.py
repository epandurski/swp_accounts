"""empty message

Revision ID: 475c15a40c10
Revises: 
Create Date: 2020-01-25 16:59:03.287735

"""
from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql

# revision identifiers, used by Alembic.
revision = '475c15a40c10'
down_revision = None
branch_labels = None
depends_on = None


def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('account',
    sa.Column('debtor_id', sa.BigInteger(), nullable=False),
    sa.Column('creditor_id', sa.BigInteger(), nullable=False),
    sa.Column('creation_date', sa.DATE(), nullable=False, comment='The date at which the account was created. This also becomes the value of the `committed_transfer_signal.account_creation_date` column for each committed transfer for the account.'),
    sa.Column('principal', sa.BigInteger(), nullable=False, comment='The owed amount, without the interest. Can be negative.'),
    sa.Column('interest_rate', sa.REAL(), nullable=False, comment='Annual rate (in percents) at which interest accumulates on the account. Can be negative.'),
    sa.Column('interest', sa.FLOAT(), nullable=False, comment='The amount of interest accumulated on the account before `last_change_ts`, but not added to the `principal` yet. Can be a negative number. `interest` gets zeroed and added to the principal once in a while (like once per week).'),
    sa.Column('locked_amount', sa.BigInteger(), nullable=False, comment='The total sum of all pending transfer locks (the total sum of the values of the `pending_transfer.sender_locked_amount` column) for this account. This value has been reserved and must be subtracted from the available amount, to avoid double-spending.'),
    sa.Column('pending_transfers_count', sa.Integer(), nullable=False, comment='The number of `pending_transfer` records for this account.'),
    sa.Column('last_change_seqnum', sa.Integer(), nullable=False, comment='Incremented (with wrapping) on every meaningful change on the account. Every change in `principal`, `interest_rate`, `interest`, `negligible_amount`, or  `status` is considered meaningful. This column, along with the `last_change_ts` column, allows to reliably determine the correct order of changes, even if they occur in a very short period of time.'),
    sa.Column('last_change_ts', sa.TIMESTAMP(timezone=True), nullable=False, comment='The moment at which the last meaningful change on the account happened. Must never decrease. Every change in `principal`, `interest_rate`, `interest`, `negligible_amount`, or `status` is considered meaningful.'),
    sa.Column('last_outgoing_transfer_date', sa.DATE(), nullable=False, comment='Updated on each transfer for which this account is the sender. It is not updated on interest/demurrage payments. This field is used to determine when an account with negative balance can be zeroed out.'),
    sa.Column('last_transfer_id', sa.BigInteger(), nullable=False, comment='Incremented when a new `prepared_transfer` record is inserted. It is used to generate sequential numbers for the `prepared_transfer.transfer_id` column. When the account is created, `last_transfer_id` has its lower 40 bits set to zero, and its higher 24 bits calculated from the value of `creation_date` (the number of days since Jan 1st, 2020).'),
    sa.Column('last_transfer_seqnum', sa.BigInteger(), nullable=False, comment='Incremented when a new `committed_transfer_signal` record is inserted. It is used to generate sequential numbers for the `committed_transfer_signal.transfer_seqnum` column. Must never decrease. When the account is created, `last_transfer_seqnum` has its lower 40 bits set to zero, and its higher 24 bits calculated from the value of `creation_date` (the number of days since Jan 1st, 2020).'),
    sa.Column('status', sa.SmallInteger(), nullable=False, comment='Additional account status bits: 1 - deleted, 2 - established interest rate, 4 - overflown, 8 - scheduled for deletion.'),
    sa.Column('negligible_amount', sa.REAL(), nullable=False, comment='An amount that is considered negligible. It is used to decide whether an account can be safely deleted or not.'),
    sa.Column('last_config_change_ts', sa.TIMESTAMP(timezone=True), nullable=False, comment='The value of the `change_ts` attribute, received with the most recent `configure_account` signal. It is used to decide whether to update the configuration when a (potentially old) `configure_account` signal is received.'),
    sa.Column('last_config_change_seqnum', sa.Integer(), nullable=False, comment='The value of the `change_seqnum` attribute, received with the most recent `configure_account` signal. It is used to decide whether to update the configuration when a (potentially old) `configure_account` signal is received.'),
    sa.CheckConstraint('interest_rate >= -50.0 AND interest_rate <= 100.0'),
    sa.CheckConstraint('last_transfer_seqnum >= 0'),
    sa.CheckConstraint('locked_amount >= 0'),
    sa.CheckConstraint('negligible_amount >= 2.0'),
    sa.CheckConstraint('pending_transfers_count >= 0'),
    sa.CheckConstraint('principal > -9223372036854775808'),
    sa.PrimaryKeyConstraint('debtor_id', 'creditor_id'),
    comment='Tells who owes what to whom.'
    )
    op.create_table('account_change_signal',
    sa.Column('debtor_id', sa.BigInteger(), nullable=False),
    sa.Column('creditor_id', sa.BigInteger(), nullable=False),
    sa.Column('change_ts', sa.TIMESTAMP(timezone=True), nullable=False),
    sa.Column('change_seqnum', sa.Integer(), nullable=False),
    sa.Column('principal', sa.BigInteger(), nullable=False),
    sa.Column('interest', sa.FLOAT(), nullable=False),
    sa.Column('interest_rate', sa.REAL(), nullable=False),
    sa.Column('last_transfer_seqnum', sa.BigInteger(), nullable=False),
    sa.Column('last_outgoing_transfer_date', sa.DATE(), nullable=False),
    sa.Column('last_config_change_ts', sa.TIMESTAMP(timezone=True), nullable=False),
    sa.Column('last_config_change_seqnum', sa.Integer(), nullable=False),
    sa.Column('creation_date', sa.DATE(), nullable=False),
    sa.Column('negligible_amount', sa.REAL(), nullable=False),
    sa.Column('status', sa.SmallInteger(), nullable=False),
    sa.PrimaryKeyConstraint('debtor_id', 'creditor_id', 'change_ts', 'change_seqnum')
    )
    op.create_table('account_purge_signal',
    sa.Column('debtor_id', sa.BigInteger(), nullable=False),
    sa.Column('creditor_id', sa.BigInteger(), nullable=False),
    sa.Column('creation_date', sa.DATE(), nullable=False),
    sa.PrimaryKeyConstraint('debtor_id', 'creditor_id', 'creation_date')
    )
    op.create_table('committed_transfer_signal',
    sa.Column('debtor_id', sa.BigInteger(), nullable=False),
    sa.Column('creditor_id', sa.BigInteger(), nullable=False),
    sa.Column('transfer_seqnum', sa.BigInteger(), nullable=False),
    sa.Column('coordinator_type', sa.String(length=30), nullable=False),
    sa.Column('committed_at_ts', sa.TIMESTAMP(timezone=True), nullable=False),
    sa.Column('committed_amount', sa.BigInteger(), nullable=False),
    sa.Column('other_creditor_id', sa.BigInteger(), nullable=False),
    sa.Column('transfer_info', postgresql.JSON(astext_type=sa.Text()), nullable=False),
    sa.Column('account_creation_date', sa.DATE(), nullable=False),
    sa.Column('account_new_principal', sa.BigInteger(), nullable=False),
    sa.PrimaryKeyConstraint('debtor_id', 'creditor_id', 'transfer_seqnum')
    )
    op.create_table('pending_account_change',
    sa.Column('debtor_id', sa.BigInteger(), nullable=False),
    sa.Column('creditor_id', sa.BigInteger(), nullable=False),
    sa.Column('change_id', sa.BigInteger(), autoincrement=True, nullable=False),
    sa.Column('principal_delta', sa.BigInteger(), nullable=False, comment='The change in `account.principal`.'),
    sa.Column('interest_delta', sa.BigInteger(), nullable=False, comment='The change in `account.interest`.'),
    sa.Column('unlocked_amount', sa.BigInteger(), nullable=True, comment='If not NULL, the value must be subtracted from `account.locked_amount`, and `account.pending_transfers_count` must be decremented.'),
    sa.Column('coordinator_type', sa.String(length=30), nullable=False),
    sa.Column('transfer_info', postgresql.JSON(astext_type=sa.Text()), nullable=True, comment='Notes from the sender. Can be any JSON object that the sender wants the recipient to see. If the account change represents a committed transfer, the notes will be included in the generated `on_committed_transfer_signal` event. Can be NULL only if `principal_delta` is zero.'),
    sa.Column('other_creditor_id', sa.BigInteger(), nullable=False, comment='If the account change represents a committed transfer, this is the other party in the transfer. When `principal_delta` is positive, this is the sender. When `principal_delta` is negative, this is the recipient. When `principal_delta` is zero, the value is irrelevant.'),
    sa.Column('inserted_at_ts', sa.TIMESTAMP(timezone=True), nullable=False),
    sa.CheckConstraint('principal_delta = 0 OR transfer_info IS NOT NULL'),
    sa.CheckConstraint('unlocked_amount >= 0'),
    sa.PrimaryKeyConstraint('debtor_id', 'creditor_id', 'change_id'),
    comment='Represents a pending change to a given account. Pending updates to `account.principal`, `account.interest`, and `account.locked_amount` are queued to this table, before being processed, because this allows multiple updates to one account to coalesce, reducing the lock contention on `account` table rows.'
    )
    op.create_table('prepared_transfer_signal',
    sa.Column('debtor_id', sa.BigInteger(), nullable=False),
    sa.Column('sender_creditor_id', sa.BigInteger(), nullable=False),
    sa.Column('transfer_id', sa.BigInteger(), nullable=False),
    sa.Column('coordinator_type', sa.String(length=30), nullable=False),
    sa.Column('coordinator_id', sa.BigInteger(), nullable=False),
    sa.Column('coordinator_request_id', sa.BigInteger(), nullable=False),
    sa.Column('sender_locked_amount', sa.BigInteger(), nullable=False),
    sa.Column('recipient_creditor_id', sa.BigInteger(), nullable=False),
    sa.Column('prepared_at_ts', sa.TIMESTAMP(timezone=True), nullable=False),
    sa.PrimaryKeyConstraint('debtor_id', 'sender_creditor_id', 'transfer_id')
    )
    op.create_table('rejected_transfer_signal',
    sa.Column('debtor_id', sa.BigInteger(), nullable=False),
    sa.Column('signal_id', sa.BigInteger(), autoincrement=True, nullable=False),
    sa.Column('coordinator_type', sa.String(length=30), nullable=False),
    sa.Column('coordinator_id', sa.BigInteger(), nullable=False),
    sa.Column('coordinator_request_id', sa.BigInteger(), nullable=False),
    sa.Column('details', postgresql.JSON(astext_type=sa.Text()), nullable=False),
    sa.PrimaryKeyConstraint('debtor_id', 'signal_id')
    )
    op.create_table('transfer_request',
    sa.Column('debtor_id', sa.BigInteger(), nullable=False),
    sa.Column('sender_creditor_id', sa.BigInteger(), nullable=False),
    sa.Column('transfer_request_id', sa.BigInteger(), autoincrement=True, nullable=False),
    sa.Column('coordinator_type', sa.String(length=30), nullable=False, comment='Indicates which subsystem has initiated the transfer and is responsible for finalizing it (coordinating the transfer). The value must be a valid python identifier, all lowercase, no double underscores. Example: direct, interest, circular.'),
    sa.Column('coordinator_id', sa.BigInteger(), nullable=False, comment='Along with `coordinator_type`, uniquely identifies who initiated the transfer.'),
    sa.Column('coordinator_request_id', sa.BigInteger(), nullable=False, comment="Along with `coordinator_type` and `coordinator_id` uniquely identifies the transfer request from the coordinator's point of view. When the transfer is prepared, those three values will be included in the generated `on_prepared_{coordinator_type}_transfer_signal` event, so that the coordinator can match the event with the originating transfer request."),
    sa.Column('min_amount', sa.BigInteger(), nullable=False, comment='The minimum amount that should be secured for the transfer. (`prepared_transfer.sender_locked_amount` will be no smaller than this value.)'),
    sa.Column('max_amount', sa.BigInteger(), nullable=False, comment='The maximum amount that should be secured for the transfer, if possible. (`prepared_transfer.sender_locked_amount` will be no bigger than this value.)'),
    sa.Column('minimum_account_balance', sa.BigInteger(), nullable=False, comment="Determines the amount that must remain available on the sender's account after the requested amount has been secured. This is useful when the coordinator does not want to expend everything available on the account."),
    sa.Column('recipient_creditor_id', sa.BigInteger(), nullable=False),
    sa.CheckConstraint('min_amount <= max_amount'),
    sa.CheckConstraint('min_amount > 0'),
    sa.PrimaryKeyConstraint('debtor_id', 'sender_creditor_id', 'transfer_request_id'),
    comment='Represents a request to secure (prepare) some amount for transfer, if it is available on a given account. If the request is fulfilled, a new row will be inserted in the `prepared_transfer` table. Requests are queued to the `transfer_request` table, before being processed, because this allows many requests from one sender to be processed at once, reducing the lock contention on `account` table rows.'
    )
    op.create_table('prepared_transfer',
    sa.Column('debtor_id', sa.BigInteger(), nullable=False),
    sa.Column('sender_creditor_id', sa.BigInteger(), nullable=False),
    sa.Column('transfer_id', sa.BigInteger(), nullable=False),
    sa.Column('coordinator_type', sa.String(length=30), nullable=False),
    sa.Column('recipient_creditor_id', sa.BigInteger(), nullable=False),
    sa.Column('sender_locked_amount', sa.BigInteger(), nullable=False, comment='The actual transferred (committed) amount may not exceed this number.'),
    sa.Column('prepared_at_ts', sa.TIMESTAMP(timezone=True), nullable=False),
    sa.CheckConstraint('sender_locked_amount > 0'),
    sa.ForeignKeyConstraint(['debtor_id', 'sender_creditor_id'], ['account.debtor_id', 'account.creditor_id'], ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('debtor_id', 'sender_creditor_id', 'transfer_id'),
    comment='A prepared transfer represent a guarantee that a particular transfer of funds will be successful if ordered (committed). A record will remain in this table until the transfer has been commited or dismissed.'
    )
    # ### end Alembic commands ###


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_table('prepared_transfer')
    op.drop_table('transfer_request')
    op.drop_table('rejected_transfer_signal')
    op.drop_table('prepared_transfer_signal')
    op.drop_table('pending_account_change')
    op.drop_table('committed_transfer_signal')
    op.drop_table('account_purge_signal')
    op.drop_table('account_change_signal')
    op.drop_table('account')
    # ### end Alembic commands ###
