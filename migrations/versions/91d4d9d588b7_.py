"""empty message

Revision ID: 91d4d9d588b7
Revises: 
Create Date: 2020-05-21 18:59:43.171898

"""
from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = '91d4d9d588b7'
down_revision = None
branch_labels = None
depends_on = None


def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('account',
    sa.Column('debtor_id', sa.BigInteger(), nullable=False),
    sa.Column('creditor_id', sa.BigInteger(), nullable=False),
    sa.Column('creation_date', sa.DATE(), nullable=False, comment='The date at which the account was created. This also becomes the value of the `account_transfer_signal.account_creation_date` column for each transfer committed from/to the account.'),
    sa.Column('principal', sa.BigInteger(), nullable=False, comment='The owed amount, without the interest. Can be negative.'),
    sa.Column('interest_rate', sa.REAL(), nullable=False, comment='Annual rate (in percents) at which interest accumulates on the account. Can be negative.'),
    sa.Column('interest', sa.FLOAT(), nullable=False, comment='The amount of interest accumulated on the account before `last_change_ts`, but not added to the `principal` yet. Can be a negative number. `interest` gets zeroed and added to the principal once in a while (like once per week).'),
    sa.Column('locked_amount', sa.BigInteger(), nullable=False, comment='The total sum of all pending transfer locks (the total sum of the values of the `pending_transfer.sender_locked_amount` column) for this account. This value has been reserved and must be subtracted from the available amount, to avoid double-spending.'),
    sa.Column('pending_transfers_count', sa.Integer(), nullable=False, comment='The number of `pending_transfer` records for this account.'),
    sa.Column('last_change_seqnum', sa.Integer(), nullable=False, comment='Incremented (with wrapping) on every meaningful change on the account. Every change in `principal`, `interest_rate`, `interest`, `negligible_amount`, or  `status` is considered meaningful. This column, along with the `last_change_ts` column, allows to reliably determine the correct order of changes, even if they occur in a very short period of time.'),
    sa.Column('last_change_ts', sa.TIMESTAMP(timezone=True), nullable=False, comment='The moment at which the last meaningful change on the account happened. Must never decrease. Every change in `principal`, `interest_rate`, `interest`, `negligible_amount`, or `status` is considered meaningful.'),
    sa.Column('last_outgoing_transfer_date', sa.DATE(), nullable=False, comment='Updated on each transfer for which this account is the sender. It is not updated on interest/demurrage payments. This field is used to determine when an account with negative balance can be zeroed out.'),
    sa.Column('last_transfer_id', sa.BigInteger(), nullable=False, comment='Incremented when a new `prepared_transfer` record is inserted. It is used to generate sequential numbers for the `prepared_transfer.transfer_id` column. When the account is created, `last_transfer_id` has its lower 40 bits set to zero, and its higher 24 bits calculated from the value of `creation_date` (the number of days since Jan 1st, 1970).'),
    sa.Column('last_transfer_number', sa.BigInteger(), nullable=False, comment='Incremented when a new `account_transfer_signal` record is inserted. It is used to generate sequential numbers for the `account_transfer_signal.transfer_number` column. Must never decrease. '),
    sa.Column('status', sa.Integer(), nullable=False, comment='Contain additional account status bits. The lower 16 bits are configured by the owner of the account: 1 - scheduled for deletion. The higher 16 bits contain internal flags: 65536 - deleted, 131072 - established interest rate, 262144 - overflown.'),
    sa.Column('negligible_amount', sa.REAL(), nullable=False, comment='An amount that is considered negligible. It is used to: 1) decide whether an account can be safely deleted; 2) decide whether a transfer is insignificant.'),
    sa.Column('last_config_ts', sa.TIMESTAMP(timezone=True), nullable=False, comment='The value of the `ts` attribute, received with the most recent `configure_account` signal. It is used to decide whether to update the configuration when a (potentially old) `configure_account` signal is received.'),
    sa.Column('last_config_seqnum', sa.Integer(), nullable=False, comment='The value of the `seqnum` attribute, received with the most recent `configure_account` signal. It is used to decide whether to update the configuration when a (potentially old) `configure_account` signal is received.'),
    sa.Column('last_reminder_ts', sa.TIMESTAMP(timezone=True), nullable=False, comment='The moment at which the last `AccountChangeSignal` was sent to remind that the account still exists. This column helps to prevent sending reminders too often.'),
    sa.CheckConstraint('interest_rate >= -50.0 AND interest_rate <= 100.0'),
    sa.CheckConstraint('last_transfer_id >= 0'),
    sa.CheckConstraint('last_transfer_number >= 0'),
    sa.CheckConstraint('locked_amount >= 0'),
    sa.CheckConstraint('negligible_amount >= 0.0'),
    sa.CheckConstraint('pending_transfers_count >= 0'),
    sa.CheckConstraint('principal > -9223372036854775808'),
    sa.PrimaryKeyConstraint('debtor_id', 'creditor_id'),
    comment='Tells who owes what to whom.'
    )
    op.create_table('account_change_signal',
    sa.Column('inserted_at_ts', sa.TIMESTAMP(timezone=True), nullable=False),
    sa.Column('debtor_id', sa.BigInteger(), nullable=False),
    sa.Column('creditor_id', sa.BigInteger(), nullable=False),
    sa.Column('signal_id', sa.BigInteger(), autoincrement=True, nullable=False),
    sa.Column('change_ts', sa.TIMESTAMP(timezone=True), nullable=False),
    sa.Column('change_seqnum', sa.Integer(), nullable=False),
    sa.Column('principal', sa.BigInteger(), nullable=False),
    sa.Column('interest', sa.FLOAT(), nullable=False),
    sa.Column('interest_rate', sa.REAL(), nullable=False),
    sa.Column('last_transfer_number', sa.BigInteger(), nullable=False),
    sa.Column('last_outgoing_transfer_date', sa.DATE(), nullable=False),
    sa.Column('last_config_ts', sa.TIMESTAMP(timezone=True), nullable=False),
    sa.Column('last_config_seqnum', sa.Integer(), nullable=False),
    sa.Column('creation_date', sa.DATE(), nullable=False),
    sa.Column('negligible_amount', sa.REAL(), nullable=False),
    sa.Column('status', sa.Integer(), nullable=False),
    sa.PrimaryKeyConstraint('debtor_id', 'creditor_id', 'signal_id')
    )
    op.create_table('account_maintenance_signal',
    sa.Column('inserted_at_ts', sa.TIMESTAMP(timezone=True), nullable=False),
    sa.Column('debtor_id', sa.BigInteger(), nullable=False),
    sa.Column('creditor_id', sa.BigInteger(), nullable=False),
    sa.Column('signal_id', sa.BigInteger(), autoincrement=True, nullable=False),
    sa.Column('request_ts', sa.TIMESTAMP(timezone=True), nullable=False),
    sa.PrimaryKeyConstraint('debtor_id', 'creditor_id', 'signal_id')
    )
    op.create_table('account_purge_signal',
    sa.Column('inserted_at_ts', sa.TIMESTAMP(timezone=True), nullable=False),
    sa.Column('debtor_id', sa.BigInteger(), nullable=False),
    sa.Column('creditor_id', sa.BigInteger(), nullable=False),
    sa.Column('creation_date', sa.DATE(), nullable=False),
    sa.PrimaryKeyConstraint('debtor_id', 'creditor_id', 'creation_date')
    )
    op.create_table('account_transfer_signal',
    sa.Column('inserted_at_ts', sa.TIMESTAMP(timezone=True), nullable=False),
    sa.Column('debtor_id', sa.BigInteger(), nullable=False),
    sa.Column('creditor_id', sa.BigInteger(), nullable=False),
    sa.Column('transfer_number', sa.BigInteger(), nullable=False),
    sa.Column('coordinator_type', sa.String(length=30), nullable=False),
    sa.Column('committed_at_ts', sa.TIMESTAMP(timezone=True), nullable=False),
    sa.Column('committed_amount', sa.BigInteger(), nullable=False),
    sa.Column('other_creditor_id', sa.BigInteger(), nullable=False),
    sa.Column('transfer_message', sa.TEXT(), nullable=False),
    sa.Column('transfer_flags', sa.Integer(), nullable=False),
    sa.Column('account_creation_date', sa.DATE(), nullable=False),
    sa.Column('account_new_principal', sa.BigInteger(), nullable=False),
    sa.Column('previous_transfer_number', sa.BigInteger(), nullable=False),
    sa.Column('system_flags', sa.Integer(), nullable=False),
    sa.PrimaryKeyConstraint('debtor_id', 'creditor_id', 'transfer_number')
    )
    op.create_table('finalized_transfer_signal',
    sa.Column('inserted_at_ts', sa.TIMESTAMP(timezone=True), nullable=False),
    sa.Column('debtor_id', sa.BigInteger(), nullable=False),
    sa.Column('sender_creditor_id', sa.BigInteger(), nullable=False),
    sa.Column('transfer_id', sa.BigInteger(), nullable=False),
    sa.Column('coordinator_type', sa.String(length=30), nullable=False),
    sa.Column('coordinator_id', sa.BigInteger(), nullable=False),
    sa.Column('coordinator_request_id', sa.BigInteger(), nullable=False),
    sa.Column('recipient_creditor_id', sa.BigInteger(), nullable=False),
    sa.Column('prepared_at_ts', sa.TIMESTAMP(timezone=True), nullable=False),
    sa.Column('finalized_at_ts', sa.TIMESTAMP(timezone=True), nullable=False),
    sa.Column('committed_amount', sa.BigInteger(), nullable=False),
    sa.Column('status_code', sa.String(length=30), nullable=False),
    sa.PrimaryKeyConstraint('debtor_id', 'sender_creditor_id', 'transfer_id')
    )
    op.create_table('pending_account_change',
    sa.Column('debtor_id', sa.BigInteger(), nullable=False),
    sa.Column('creditor_id', sa.BigInteger(), nullable=False),
    sa.Column('change_id', sa.BigInteger(), autoincrement=True, nullable=False),
    sa.Column('principal_delta', sa.BigInteger(), nullable=False, comment='The change in `account.principal`.'),
    sa.Column('interest_delta', sa.BigInteger(), nullable=False, comment='The change in `account.interest`.'),
    sa.Column('unlocked_amount', sa.BigInteger(), nullable=True, comment='If not NULL, the value must be subtracted from `account.locked_amount`, and `account.pending_transfers_count` must be decremented.'),
    sa.Column('coordinator_type', sa.String(length=30), nullable=False),
    sa.Column('transfer_message', sa.TEXT(), nullable=True, comment='Notes from the sender. Can be any string that the sender wants the recipient to see. If the account change represents a committed transfer, the notes will be included in the generated `on_account_transfer_signal` event, otherwise the notes are ignored. Can be NULL only if `principal_delta` is zero.'),
    sa.Column('transfer_flags', sa.Integer(), nullable=True, comment='Contains various flags that characterize the committed transfer. If the account change represents a committed transfer, the flags will be included in the generated `on_account_transfer_signal` event, otherwise the flags are ignored. Can be NULL only if `principal_delta` is zero.'),
    sa.Column('other_creditor_id', sa.BigInteger(), nullable=False, comment='If the account change represents a committed transfer, this is the other party in the transfer. When `principal_delta` is positive, this is the sender. When `principal_delta` is negative, this is the recipient. When `principal_delta` is zero, the value is irrelevant.'),
    sa.Column('inserted_at_ts', sa.TIMESTAMP(timezone=True), nullable=False),
    sa.CheckConstraint('principal_delta = 0 OR transfer_flags IS NOT NULL'),
    sa.CheckConstraint('principal_delta = 0 OR transfer_message IS NOT NULL'),
    sa.CheckConstraint('unlocked_amount >= 0'),
    sa.PrimaryKeyConstraint('debtor_id', 'creditor_id', 'change_id'),
    comment='Represents a pending change to a given account. Pending updates to `account.principal`, `account.interest`, and `account.locked_amount` are queued to this table, before being processed, because this allows multiple updates to one account to coalesce, reducing the lock contention on `account` table rows.'
    )
    op.create_table('prepared_transfer_signal',
    sa.Column('inserted_at_ts', sa.TIMESTAMP(timezone=True), nullable=False),
    sa.Column('debtor_id', sa.BigInteger(), nullable=False),
    sa.Column('sender_creditor_id', sa.BigInteger(), nullable=False),
    sa.Column('signal_id', sa.BigInteger(), autoincrement=True, nullable=False),
    sa.Column('transfer_id', sa.BigInteger(), nullable=False),
    sa.Column('coordinator_type', sa.String(length=30), nullable=False),
    sa.Column('coordinator_id', sa.BigInteger(), nullable=False),
    sa.Column('coordinator_request_id', sa.BigInteger(), nullable=False),
    sa.Column('sender_locked_amount', sa.BigInteger(), nullable=False),
    sa.Column('recipient_creditor_id', sa.BigInteger(), nullable=False),
    sa.Column('prepared_at_ts', sa.TIMESTAMP(timezone=True), nullable=False),
    sa.PrimaryKeyConstraint('debtor_id', 'sender_creditor_id', 'signal_id')
    )
    op.create_table('rejected_config_signal',
    sa.Column('inserted_at_ts', sa.TIMESTAMP(timezone=True), nullable=False),
    sa.Column('debtor_id', sa.BigInteger(), nullable=False),
    sa.Column('creditor_id', sa.BigInteger(), nullable=False),
    sa.Column('signal_id', sa.BigInteger(), autoincrement=True, nullable=False),
    sa.Column('config_ts', sa.TIMESTAMP(timezone=True), nullable=False),
    sa.Column('config_seqnum', sa.Integer(), nullable=False),
    sa.Column('config_flags', sa.SmallInteger(), nullable=False),
    sa.Column('negligible_amount', sa.REAL(), nullable=False),
    sa.Column('config', sa.String(), nullable=False),
    sa.Column('rejection_code', sa.String(length=30), nullable=False),
    sa.PrimaryKeyConstraint('debtor_id', 'creditor_id', 'signal_id')
    )
    op.create_table('rejected_transfer_signal',
    sa.Column('inserted_at_ts', sa.TIMESTAMP(timezone=True), nullable=False),
    sa.Column('debtor_id', sa.BigInteger(), nullable=False),
    sa.Column('sender_creditor_id', sa.BigInteger(), nullable=False),
    sa.Column('signal_id', sa.BigInteger(), autoincrement=True, nullable=False),
    sa.Column('coordinator_type', sa.String(length=30), nullable=False),
    sa.Column('coordinator_id', sa.BigInteger(), nullable=False),
    sa.Column('coordinator_request_id', sa.BigInteger(), nullable=False),
    sa.Column('rejection_code', sa.String(length=30), nullable=False),
    sa.Column('available_amount', sa.BigInteger(), nullable=False),
    sa.Column('recipient_creditor_id', sa.BigInteger(), nullable=False),
    sa.PrimaryKeyConstraint('debtor_id', 'sender_creditor_id', 'signal_id')
    )
    op.create_table('transfer_request',
    sa.Column('debtor_id', sa.BigInteger(), nullable=False),
    sa.Column('sender_creditor_id', sa.BigInteger(), nullable=False),
    sa.Column('transfer_request_id', sa.BigInteger(), autoincrement=True, nullable=False),
    sa.Column('coordinator_type', sa.String(length=30), nullable=False, comment='Indicates which subsystem has initiated the transfer and is responsible for finalizing it (coordinating the transfer). The value must be a valid python identifier, all lowercase, no double underscores. Example: direct, interest, circular.'),
    sa.Column('coordinator_id', sa.BigInteger(), nullable=False, comment='Along with `coordinator_type`, uniquely identifies who initiated the transfer.'),
    sa.Column('coordinator_request_id', sa.BigInteger(), nullable=False, comment="Along with `coordinator_type` and `coordinator_id` uniquely identifies the transfer request from the coordinator's point of view. When the transfer is prepared, those three values will be included in the generated `on_prepared_{coordinator_type}_transfer_signal` event, so that the coordinator can match the event with the originating transfer request."),
    sa.Column('min_amount', sa.BigInteger(), nullable=False, comment='The minimum amount that should be secured for the transfer. (`prepared_transfer.sender_locked_amount` will be no smaller than this value.)'),
    sa.Column('max_amount', sa.BigInteger(), nullable=False, comment='The maximum amount that should be secured for the transfer, if possible. (`prepared_transfer.sender_locked_amount` will be no bigger than this value.)'),
    sa.Column('minimum_account_balance', sa.BigInteger(), nullable=False, comment="Determines the amount that must remain available on the sender's account after the requested amount has been secured. This is useful when the coordinator does not want to expend everything available on the account."),
    sa.Column('recipient_creditor_id', sa.BigInteger(), nullable=False),
    sa.CheckConstraint('min_amount <= max_amount'),
    sa.CheckConstraint('min_amount > 0'),
    sa.PrimaryKeyConstraint('debtor_id', 'sender_creditor_id', 'transfer_request_id'),
    comment='Represents a request to secure (prepare) some amount for transfer, if it is available on a given account. If the request is fulfilled, a new row will be inserted in the `prepared_transfer` table. Requests are queued to the `transfer_request` table, before being processed, because this allows many requests from one sender to be processed at once, reducing the lock contention on `account` table rows.'
    )
    op.create_table('prepared_transfer',
    sa.Column('debtor_id', sa.BigInteger(), nullable=False),
    sa.Column('sender_creditor_id', sa.BigInteger(), nullable=False),
    sa.Column('transfer_id', sa.BigInteger(), nullable=False),
    sa.Column('coordinator_type', sa.String(length=30), nullable=False),
    sa.Column('coordinator_id', sa.BigInteger(), nullable=False),
    sa.Column('coordinator_request_id', sa.BigInteger(), nullable=False),
    sa.Column('sender_locked_amount', sa.BigInteger(), nullable=False, comment='The actual transferred (committed) amount may not exceed this number.'),
    sa.Column('recipient_creditor_id', sa.BigInteger(), nullable=False),
    sa.Column('prepared_at_ts', sa.TIMESTAMP(timezone=True), nullable=False),
    sa.Column('last_reminder_ts', sa.TIMESTAMP(timezone=True), nullable=True, comment='The moment at which the last `PreparedTransferSignal` was sent to remind that the prepared transfer must be finalized. A `NULL` means that no reminders have been sent yet. This column helps to prevent sending reminders too often.'),
    sa.CheckConstraint('sender_locked_amount > 0'),
    sa.CheckConstraint('transfer_id > 0'),
    sa.ForeignKeyConstraint(['debtor_id', 'sender_creditor_id'], ['account.debtor_id', 'account.creditor_id'], ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('debtor_id', 'sender_creditor_id', 'transfer_id'),
    comment='A prepared transfer represent a guarantee that a particular transfer of funds will be successful if ordered (committed). A record will remain in this table until the transfer has been committed or dismissed.'
    )
    # ### end Alembic commands ###


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_table('prepared_transfer')
    op.drop_table('transfer_request')
    op.drop_table('rejected_transfer_signal')
    op.drop_table('rejected_config_signal')
    op.drop_table('prepared_transfer_signal')
    op.drop_table('pending_account_change')
    op.drop_table('finalized_transfer_signal')
    op.drop_table('account_transfer_signal')
    op.drop_table('account_purge_signal')
    op.drop_table('account_maintenance_signal')
    op.drop_table('account_change_signal')
    op.drop_table('account')
    # ### end Alembic commands ###
